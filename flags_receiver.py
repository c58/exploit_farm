#!/usr/bin/env python
import os
from os.path     import basename, splitext, exists
import socket
from threading import Thread
from time import strftime

# Listened port
SPLOIT_RECV_PORT = 3366
__author__ = 'c58'


def log(text):
    print(strftime("%H:%M:%S") + " " + text)


def get_flag_filename(team_name, sploit_name):
    spl_short_name = splitext(basename(sploit_name))[0]
    return "flags/%s_%s.txt" % (spl_short_name, team_name)


##
# Client handling logic
# Each new line is flag posting command with format: <flag> <team_name> <sploit_name>
# If received empty line it closes the connection
#
class ClientThread(Thread):
    def __init__(self, ip, port, socket):
        super(ClientThread, self).__init__()
        self.ip = ip
        self.port = port
        self.socket = socket
        log("Client connected from %s" % str(ip))

    def readlines(self, buf_size=4096):
        chunks = []
        while True:
            try:
                chunk = self.socket.recv(buf_size)
                if not chunk:
                    if chunks:
                        yield ''.join(chunks)
                    break
                if not '\n' in chunk:
                    chunks.append(chunk)
                    continue
                chunk = chunk.split('\n')
                if chunks:
                    yield ''.join(chunks + [chunk[0]])
                else:
                    yield chunk[0]
                for line in chunk[1:-1]:
                    yield line
                if chunk[-1]:
                    chunks = [chunk[-1]]
                else:
                    chunks = []
            except:
                break

    def stop(self):
        self.socket.shutdown(2)
        self.socket.close()

    def run(self):
        for line in self.readlines():
            if line.strip() == '':
                self.stop()
                break

            self.process_command(line)

    def send_error(self, msg):
        self.socket.sendall("Command error: " + msg + b"\n")

    # Command processing logic there
    def process_command(self, line):
        # Validate command
        parts = [x.strip() for x in line.split(' ')]
        if len(parts) is not 3:
            return self.send_error('must contain exactly 3 arguments')

        # Write flag to file
        with open(get_flag_filename(parts[1], parts[2]), "ab") as f:
            f.write(parts[0] + b"\n")

        log('Flag "%s" from %s/%s team "%s" saved' % (parts[0], self.ip, parts[2], parts[1]))


##
# Flag receiver server starter
#
def main():
    # List of client threads
    threads = []

    # ensure that flag dir is exists
    if not exists("flags"):
        os.makedirs("flags")

    # Create TCP server on `cfg.SPLOIT_RECV_PORT` port
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(('0.0.0.0', SPLOIT_RECV_PORT))
    log("Listening sploits on port %i..." % SPLOIT_RECV_PORT)

    # Listen to new client connections
    s.listen(1)
    while True:
        try:
            (client, (ip, port)) = s.accept()
            th = ClientThread(ip, port, client)
            th.start()
            threads.append(th)
        except KeyboardInterrupt:
            log('Stop sploit posting server!')
            break
        except socket.error, msg:
            log("Socket error! %s" % msg)

    # Cleanup when server stopped
    for t in threads:
        t.stop()
        t.join()

if __name__ == "__main__":
    main()
