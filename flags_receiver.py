#!/usr/bin/env python
import os
from os.path     import basename, splitext, exists
import socket
from threading import Thread
from time import strftime
import config as cfg
from lxml import etree

__author__ = 'c58'
flagstat = {0: {}}
round = 0

def log(text):
    print(strftime("%H:%M:%S") + " " + text)


def get_flag_filename(team_name, sploit_name):
    spl_short_name = splitext(basename(sploit_name))[0]
    return "flags/%s_%s.txt" % (spl_short_name, team_name)


##
# Client handling logic
# Each new line is flag posting command with format: <flag> <team_name> <sploit_name>
# If received empty line it closes the connection
#
class ClientThread(Thread):
    def __init__(self, ip, port, socket):
        super(ClientThread, self).__init__()
        self.ip = ip
        self.port = port
        self.socket = socket
        log("Client connected from %s" % str(ip))

    def readlines(self, buf_size=4096):
        chunks = []
        while True:
            try:
                chunk = self.socket.recv(buf_size)
            except:
                break

            if not chunk:
                if chunks:
                    yield ''.join(chunks)
                break
            if not '\n' in chunk:
                chunks.append(chunk)
                continue
            chunk = chunk.split('\n')
            if chunks:
                yield ''.join(chunks + [chunk[0]])
            else:
                yield chunk[0]
            for line in chunk[1:-1]:
                yield line
            if chunk[-1]:
                chunks = [chunk[-1]]
            else:
                chunks = []

    def stop(self):
        try:
            self.socket.shutdown(2)
            self.socket.close()
        except:
            pass

    def run(self):
        for line in self.readlines():
            if line.strip() == '':
                self.stop()
                break

            self.process_command(line)

    def send_error(self, msg):
        self.socket.sendall("Command error: " + msg + b"\n")

    # Command processing logic there
    def process_command(self, line):
        # Validate command
        parts = [x.strip() for x in line.split(' ')]
        if len(parts) is not 3:
            return self.send_error('must contain exactly 3 arguments')

        # Write flag to file
        with open(get_flag_filename(parts[1], parts[2]), "ab") as f:
            f.write(parts[0] + b"\n")
            key = parts[1] + "_" + parts[2]
            if key in self.flagstat[self.round]:
                flagstat[round][key] += 1
            else:
                flagstat[round][key] = 1

        log('Flag "%s" from %s/%s team "%s" saved' % (parts[0], self.ip, parts[2], parts[1]))

def nextround():
    self.flagstat[++self.round] = {}
        
# Flagstat import to xml
def importstat():
    ctf = etree.Element("ctf")
    services = etree.subElement(ctf, "services")
    for service in cfg.SERVICES:
        node = etree.subElement(services, "service")
        node.attrib["name"] = service
    teams = etree.subElement(ctf, "teams")
    for team in cfg.TEAMS:
        node = etree.subElement(teams, "team")
        node.attrib["name"] = team
    rounds = etree.subElement(ctf, "rounds")
    for roundNum, stat in flagstat:
        roundNode = etree.subElement(rounds, "round")
        roundNode.attrib["number"] = roundNum
        for info, amount in stat:
            team = info.split('_')[0]
            service = info.split('_')[1]
            flags = etree.subElement(roundNode, "flags")
            flags.attrib["team"] = team
            flags.attrib["service"] = service
            flags.attrib["amount"] = amount
    with open("flagstat.xml", "ab") as f:
        f.write(etree.toString(root, pretty_print=True))
    nextround()
    threading.Timer(60*5, importstat).start()

##
# Flag receiver server starter
#
def main():
    # List of client threads
    threads = []

    # ensure that flag dir is exists
    if not exists("flags"):
        os.makedirs("flags")

    # Create TCP server on `cfg.SPLOIT_RECV_PORT` port
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(('0.0.0.0', cfg.FLAGS_RECEIVER['PORT']))
    log("Listening sploits on port %i..." % cfg.FLAGS_RECEIVER['PORT'])

    # Listen to new client connections
    s.listen(1)
    while True:
        try:
            (client, (ip, port)) = s.accept()
            th = ClientThread(ip, port, client)
            th.start()
            threads.append(th)
        except KeyboardInterrupt:
            log('Stop sploit posting server!')
            break
        except socket.error, msg:
            log("Socket error! %s" % msg)

    # Cleanup when server stopped
    for t in threads:
        t.stop()
        t.join()

if __name__ == "__main__":
    main()
